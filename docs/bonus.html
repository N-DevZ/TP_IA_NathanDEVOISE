
                <!DOCTYPE html>
                <html lang="fr">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Documentation - bonus</title>
                    <link rel="stylesheet" href="style.css">
                </head>
                <body>
                <h1>Module: bonus</h1>
            <h2>Contenu du module</h2>
<h3>Imports</h3>
<ul>
<li><code>import streamlit</code></li>
<li><code>from lazypredict.Supervised import LazyClassifier</code></li>
<li><code>from sklearn.model_selection import GridSearchCV</code></li>
<li><code>from sklearn.linear_model import LogisticRegression</code></li>
<li><code>import torch</code></li>
<li><code>import torch.nn</code></li>
<li><code>import torch.optim</code></li>
<li><code>from torch.utils.data import TensorDataset, DataLoader</code></li>
</ul>
<h3>FunctionDef: run_bonus</h3>
<h4>Arguments</h4>
<ul>
<li><code>X_train</code></li>
<li><code>X_test</code></li>
<li><code>y_train</code></li>
<li><code>y_test</code></li>
<li><code>features</code></li>
</ul>
<h4>Contenu de la fonction</h4>
<pre>
st.title('Fonctionnalités bonus')
Si st.checkbox('Exécuter Lazy Predict'):
    clf = LazyClassifier(verbose=0, ignore_warnings=True, custom_metric=None)
    models, predictions = clf.fit(X_train, X_test, y_train, y_test)
    st.write(models)
Si st.checkbox('Exécuter GridSearchCV'):
    param_grid = {'C': [0.1, 1, 10], 'penalty': ['l2']}
    grid_search = GridSearchCV(LogisticRegression(solver='lbfgs'), param_grid, cv=5)
    grid_search.fit(X_train, y_train)
    st.write('Meilleurs paramètres:', grid_search.best_params_)
    st.write('Meilleur score:', grid_search.best_score_)
Si st.checkbox('Entraîner un modèle de Deep Learning (PyTorch)'):
    run_deep_learning(X_train, y_train, features)
</pre>
<h3>FunctionDef: run_deep_learning</h3>
<h4>Arguments</h4>
<ul>
<li><code>X_train</code></li>
<li><code>y_train</code></li>
<li><code>features</code></li>
</ul>
<h4>Contenu de la fonction</h4>
<pre>
class WineNet(nn.Module):

    def __init__(self, input_dim):
        super(WineNet, self).__init__()
        self.fc1 = nn.Linear(input_dim, 64)
        self.relu1 = nn.ReLU()
        self.fc2 = nn.Linear(64, 32)
        self.relu2 = nn.ReLU()
        self.fc3 = nn.Linear(32, 3)

    def forward(self, x):
        x = self.relu1(self.fc1(x))
        x = self.relu2(self.fc2(x))
        x = self.fc3(x)
        return x
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
X_train_t = torch.tensor(X_train.values, dtype=torch.float32).to(device)
y_train_t = torch.tensor(y_train.values, dtype=torch.long).to(device)
dataset = TensorDataset(X_train_t, y_train_t)
loader = DataLoader(dataset, batch_size=32, shuffle=True)
model = WineNet(len(features)).to(device)
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)
epochs = 50
loss_history = []
for epoch in range(epochs):
    model.train()
    running_loss = 0.0
    for inputs, labels in loader:
        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        running_loss += loss.item()
    loss_history.append(running_loss / len(loader))
st.line_chart(loss_history)
st.success('Modèle Deep Learning entraîné avec PyTorch !')
</pre>
</body></html>