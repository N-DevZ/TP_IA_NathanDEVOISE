
                <!DOCTYPE html>
                <html lang="fr">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Documentation - deep_learning</title>
                    <link rel="stylesheet" href="style.css">
                </head>
                <body>
                <h1>Module: deep_learning</h1>
            <h2>Contenu du module</h2>
<h3>Imports</h3>
<ul>
<li><code>import streamlit</code></li>
<li><code>import torch</code></li>
<li><code>import torch.nn</code></li>
<li><code>import torch.optim</code></li>
<li><code>from torch.utils.data import TensorDataset, DataLoader</code></li>
<li><code>import pandas</code></li>
</ul>
<h3>FunctionDef: run_deep_learning</h3>
<h4>Arguments</h4>
<ul>
<li><code>data</code></li>
</ul>
<h4>Contenu de la fonction</h4>
<pre>
st.title('Deep Learning avec PyTorch')
X = data.drop(['target', 'target_encoded'], axis=1)
y = data['target_encoded']
X_tensor = torch.FloatTensor(X.values)
y_tensor = torch.LongTensor(y.values)
dataset = TensorDataset(X_tensor, y_tensor)
dataloader = DataLoader(dataset, batch_size=32, shuffle=True)
class WineNet(nn.Module):

    def __init__(self, input_size):
        super(WineNet, self).__init__()
        self.fc1 = nn.Linear(input_size, 64)
        self.fc2 = nn.Linear(64, 32)
        self.fc3 = nn.Linear(32, 3)

    def forward(self, x):
        x = torch.relu(self.fc1(x))
        x = torch.relu(self.fc2(x))
        x = self.fc3(x)
        return x
model = WineNet(X.shape[1])
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters())
Si st.button('Entraîner le modèle de Deep Learning'):
    epochs = 50
    for epoch in range(epochs):
    for inputs, labels in dataloader:
        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
    if (epoch + 1) % 10 == 0:
        st.write(f'Epoch [{epoch + 1}/{epochs}], Loss: {loss.item():.4f}')
    st.success('Entraînement terminé!')
Si st.button('Évaluer le modèle'):
    model.eval()
    with torch.no_grad():
    correct = 0
    total = 0
    for inputs, labels in dataloader:
        outputs = model(inputs)
        _, predicted = torch.max(outputs.data, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()
    accuracy = 100 * correct / total
    st.write(f'Précision du modèle: {accuracy:.2f}%')
</pre>
</body></html>